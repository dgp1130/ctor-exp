/** @fileoverview Examples of basic `ctor<T>` usage. */

import { ctor, from, Implementation } from './ctor';

describe('ctor', () => {
    it('constructs a class', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public fooMethod(): string {
                return 'fooMethod';
            }
        }

        const foo = ctor.new(Foo, { foo: 'foo' }).construct();
        expect(foo).toBeInstanceOf(Foo);
        expect(foo.foo).toBe('foo');
        expect(foo.fooMethod()).toBe('fooMethod');
    });

    it('extends a class', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public fooMethod(): string {
                return 'fooMethod';
            }
        }

        class Bar extends Implementation<Foo>() {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            public barMethod(): string {
                return 'barMethod';
            }
        }

        const fooCtor = ctor.new(Foo, { foo: 'foo' });
        const bar = from(fooCtor).new(Bar, { bar: 'bar' }).construct();
        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);
        expect(bar.foo).toBe('foo');
        expect(bar.fooMethod()).toBe('fooMethod');
        expect(bar.bar).toBe('bar');
        expect(bar.barMethod()).toBe('barMethod');
    });

    it('transitively extends an inheritance hierarchy', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public fooMethod(): string {
                return 'fooMethod';
            }
        }

        class Bar extends Implementation<Foo>() {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            public barMethod(): string {
                return 'barMethod';
            }
        }

        class Baz extends Implementation<Bar>() {
            public readonly baz: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ baz }: { baz: string }) {
                super();
                this.baz = baz;
            }

            public bazMethod(): string {
                return 'bazMethod';
            }
        }

        const fooCtor = ctor.new(Foo, { foo: 'foo' });
        const barCtor = from(fooCtor).new(Bar, { bar: 'bar' });
        const baz = from(barCtor).new(Baz, { baz: 'baz' }).construct();

        expect(baz).toBeInstanceOf(Foo);
        expect(baz).toBeInstanceOf(Bar);
        expect(baz).toBeInstanceOf(Baz);

        expect(baz.foo).toBe('foo');
        expect(baz.fooMethod()).toBe('fooMethod');
        expect(baz.bar).toBe('bar');
        expect(baz.barMethod()).toBe('barMethod');
        expect(baz.baz).toBe('baz');
        expect(baz.bazMethod()).toBe('bazMethod');
    });

    it('extends an abstract class', () => {
        type FooParams = [ { foo: string } ];
        abstract class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor(...[ { foo } ]: FooParams) {
                this.foo = foo;
            }

            public fooMethod(): string {
                return 'fooMethod';
            }

            public abstract abstractFooMethod(): string;
        }

        class Bar extends Implementation<Foo>() {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            // Override.
            public abstractFooMethod(): string {
                return 'abstractFooMethod';
            }
        }

        const fooCtor = ctor.newAbstract<typeof Foo, FooParams>(Foo, {
            foo: 'foo',
        });
        const bar = from(fooCtor).new(Bar, { bar: 'bar' }).construct();

        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);

        expect(bar.foo).toBe('foo');
        expect(bar.fooMethod()).toBe('fooMethod');
        expect(bar.bar).toBe('bar');
        expect(bar.abstractFooMethod()).toBe('abstractFooMethod');
    });

    it('supports generics', () => {
        class Foo<T> {
            public readonly value: T;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ value }: { value: T }) {
                this.value = value;
            }

            public static from<T>(value: T): Foo<T> {
                return Foo.extend(value).construct();
            }

            public static extend<T>(value: T): ctor<Foo<T>> {
                // Ctor has a return-only generic, so generic classes need to be
                // casted to the correct T value.
                return ctor.new(Foo, { value }) as ctor<Foo<T>>;
            }
        }

        const foo = Foo.from('test');
        expect(foo).toBeInstanceOf(Foo);
        expect(foo.value).toBe('test');
        // @ts-expect-error `foo.value` should be typed as string.
        ((x: number) => x = foo.value);

        // @ts-ignore In TypeScript, type parameters are not in scope for
        // superclass declarations because type T is not known when the class
        // hierarchy is created. This makes sense in TypeScript, but not for
        // `ctor<T>`, where the class hierarchy is dynamic until it is
        // constructed. We simply ignore the type error for now.
        // See: https://github.com/microsoft/TypeScript/issues/26154#issuecomment-410848076
        class Bar<T1, T2> extends Implementation<Foo<T1>>() {
            public readonly value2: T2;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ value2 }: { value2: T2 }) {
                super();
                this.value2 = value2;
            }

            public static from<T1, T2>(value: T1, value2: T2): Bar<T1, T2> {
                const barCtor = from(Foo.extend(value))
                        .new(Bar, { value2 }) as ctor<Bar<T1, T2>>;
                return barCtor.construct();
            }
        }

        const bar = Bar.from('test', 1);
        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);
        expect(bar.value).toBe('test');
        expect(bar.value2).toBe(1);
        // `bar.value` **should** be typed as string, but TypeScript's generic
        // limitations mean this is currently incorrectly typed as `any`.
        ((x: number) => x = bar.value);
        // @ts-expect-error `bar.value2` should be typed as number.
        ((x: string) => x = bar.value2);
    });

    it('allows static factories of the same name across inherited classes', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public static from(foo: string): ctor<Foo> {
                return ctor.new(Foo, { foo });
            }
        }

        class Bar extends Implementation<Foo>() {
            public readonly bar: string;

            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            // Same name as `Foo.from()`, but should not conflict.
            public static from(foo: string, bar: string): Bar {
                return from(Foo.from(foo)).new(Bar, { bar }).construct();
            }
        }

        const bar = Bar.from('foo', 'bar');
        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);
        expect(bar.foo).toBe('foo');
        expect(bar.bar).toBe('bar');
    });

    it('`instanceof` works as expected', () => {
        class Foo { }
        class Bar extends Foo { }
        class Baz extends Bar { }
        class Unrelated { }

        const foo = ctor.new(Foo).construct();
        expect(foo).toBeInstanceOf(Foo);

        const bar = from(ctor.new(Bar)).new(Foo).construct();
        expect(bar).toBeInstanceOf(Bar);
        expect(bar).toBeInstanceOf(Foo);

        const baz = from(from(ctor.new(Bar)).new(Foo)).new(Baz).construct();
        expect(baz).toBeInstanceOf(Baz);
        expect(baz).toBeInstanceOf(Bar);
        expect(baz).toBeInstanceOf(Foo);

        expect(baz).not.toBeInstanceOf(Unrelated);
    });

    it('extends Object', () => {
        class Foo { }
        class Bar extends Implementation<Foo>() { }

        const foo = ctor.new(Foo).construct();
        expect(foo).toBeInstanceOf(Object);

        const bar = from(ctor.new(Foo)).new(Bar).construct();
        expect(bar).toBeInstanceOf(Object);
    });

    it('chooses its superclass implementation at construction time', () => {
        interface Parent {
            parent: string;
            parentMethod(): string;
        }

        class ParentA implements Parent {
            public readonly parent: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ parent }: { parent: string }) {
                this.parent = parent;
            }

            public parentMethod(): string {
                return 'parentMethodA';
            }

            public static from(parent: string): ctor<ParentA> {
                return ctor.new(ParentA, { parent: `${parent}A` });
            }
        }

        class ParentB implements Parent {
            public readonly parent: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ parent }: { parent: string }) {
                this.parent = parent;
            }

            public parentMethod(): string {
                return 'parentMethodB';
            }

            public static from(parent: string): ctor<ParentB> {
                return ctor.new(ParentB, { parent: `${parent}B` });
            }
        }

        class Child extends Implementation<Parent>() {
            public readonly child: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ child }: { child: string }) {
                super();
                this.child = child;
            }

            public childMethod(): string {
                return 'childMethod';
            }

            public static from(
                    parent: string, child: string, useParentA: boolean): Child {
                // Dynamically choose which superclass to inherit from at
                // construction time.
                const parentCtor = useParentA
                        ? ParentA.from(parent) : ParentB.from(parent);
                return from(parentCtor).new(Child, { child }).construct();
            }

            // Allow user of Child to choose which Parent implementation to use.
            public static fromParent(
                    parentCtor: ctor<Parent>, child: string): Child {
                return from(parentCtor).new(Child, { child }).construct();
            }
        }

        const childA1 = Child.from('parent', 'child', true /* useParentA */);
        expect(childA1).toBeInstanceOf(Child);
        expect(childA1).toBeInstanceOf(ParentA);
        expect(childA1.child).toBe('child');
        expect(childA1.childMethod()).toBe('childMethod');
        expect(childA1.parent).toBe('parentA');
        expect(childA1.parentMethod()).toBe('parentMethodA');
        // @ts-expect-error Should not have `any` index type.
        (() => childA1.doesNotExist);

        const childB1 = Child.from('parent', 'child', false /* useParentA */);
        expect(childB1).toBeInstanceOf(Child);
        expect(childB1).toBeInstanceOf(ParentB);
        expect(childB1.child).toBe('child');
        expect(childB1.childMethod()).toBe('childMethod');
        expect(childB1.parent).toBe('parentB');
        expect(childB1.parentMethod()).toBe('parentMethodB');
        // @ts-expect-error Should not have `any` index type.
        (() => childB1.doesNotExist);

        const childA2 = Child.fromParent(ParentA.from('parent'), 'child');
        expect(childA2).toBeInstanceOf(Child);
        expect(childA2).toBeInstanceOf(ParentA);
        expect(childA2.child).toBe('child');
        expect(childA2.childMethod()).toBe('childMethod');
        expect(childA2.parent).toBe('parentA');
        expect(childA2.parentMethod()).toBe('parentMethodA');
        // @ts-expect-error Should not have `any` index type.
        (() => childA2.doesNotExist);

        const childB2 = Child.fromParent(ParentB.from('parent'), 'child');
        expect(childB2).toBeInstanceOf(Child);
        expect(childB2).toBeInstanceOf(ParentB);
        expect(childB2.child).toBe('child');
        expect(childB2.childMethod()).toBe('childMethod');
        expect(childB2.parent).toBe('parentB');
        expect(childB2.parentMethod()).toBe('parentMethodB');
        // @ts-expect-error Should not have `any` index type.
        (() => childB2.doesNotExist);
    });

    it('can extend a subclass of the intended superclass', () => {
        class Foo {
            public method(): string {
                return 'foo';
            }

            public static from(): ctor<Foo> {
                return ctor.new(Foo);
            }
        }
        class Bar extends Implementation<Foo>() {
            public method(): string {
                return 'bar';
            }

            public static from(parentCtor: ctor<Foo>): ctor<Bar> {
                return from(parentCtor).new(Bar);
            }
        }
        class Baz extends Implementation<Foo>() {
            public static from(parentCtor: ctor<Foo>): ctor<Baz> {
                return from(parentCtor).new(Baz);
            }
        }

        const correctBaz = Baz.from(Foo.from()).construct();
        expect(correctBaz).toBeInstanceOf(Baz);
        expect(correctBaz).toBeInstanceOf(Foo);
        expect(correctBaz).not.toBeInstanceOf(Bar);
        expect(correctBaz.method()).toBe('foo');

        // Incorrectly extend `Baz` from `Bar`, which technically satisfies the
        // superclass requirement of `Foo`, even though `Bar` is not really
        // intended to be extended.
        const incorrectBaz = Baz.from(Bar.from(Foo.from())).construct();
        expect(incorrectBaz).toBeInstanceOf(Baz);
        expect(incorrectBaz).toBeInstanceOf(Bar); // Unexpected.
        expect(incorrectBaz).toBeInstanceOf(Foo);
        expect(incorrectBaz.method()).toBe('bar'); // Uses `Bar`'s version.
    });
});
