/** @fileoverview Examples of basic `ctor<T>` usage. */

import { ctor, from, Implementation } from './ctor';

describe('ctor', () => {
    it('constructs a class', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public fooMethod(): string {
                return 'fooMethod';
            }
        }

        const foo = ctor.new(Foo, { foo: 'foo' }).construct();
        expect(foo).toBeInstanceOf(Foo);
        expect(foo.foo).toBe('foo');
        expect(foo.fooMethod()).toBe('fooMethod');
    });

    it('extends a class', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public fooMethod(): string {
                return 'fooMethod';
            }
        }

        class Bar extends Implementation<Foo>() {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            public barMethod(): string {
                return 'barMethod';
            }
        }

        const fooCtor = ctor.new(Foo, { foo: 'foo' });
        const bar = from(fooCtor).new(Bar, { bar: 'bar' }).construct();
        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);
        expect(bar.foo).toBe('foo');
        expect(bar.fooMethod()).toBe('fooMethod');
        expect(bar.bar).toBe('bar');
        expect(bar.barMethod()).toBe('barMethod');
    });

    it('transitively extends an inheritance hierarchy', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public fooMethod(): string {
                return 'fooMethod';
            }
        }

        class Bar extends Implementation<Foo>() {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            public barMethod(): string {
                return 'barMethod';
            }
        }

        class Baz extends Implementation<Bar>() {
            public readonly baz: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ baz }: { baz: string }) {
                super();
                this.baz = baz;
            }

            public bazMethod(): string {
                return 'bazMethod';
            }
        }

        const fooCtor = ctor.new(Foo, { foo: 'foo' });
        const barCtor = from(fooCtor).new(Bar, { bar: 'bar' });
        const baz = from(barCtor).new(Baz, { baz: 'baz' }).construct();

        expect(baz).toBeInstanceOf(Foo);
        expect(baz).toBeInstanceOf(Bar);
        expect(baz).toBeInstanceOf(Baz);

        expect(baz.foo).toBe('foo');
        expect(baz.fooMethod()).toBe('fooMethod');
        expect(baz.bar).toBe('bar');
        expect(baz.barMethod()).toBe('barMethod');
        expect(baz.baz).toBe('baz');
        expect(baz.bazMethod()).toBe('bazMethod');
    });

    it('extends an abstract class', () => {
        type FooParams = [ { foo: string } ];
        abstract class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor(...[ { foo } ]: FooParams) {
                this.foo = foo;
            }

            public fooMethod(): string {
                return 'fooMethod';
            }

            public abstract abstractFooMethod(): string;
        }

        class Bar extends Implementation<Foo>() {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            // Override.
            public abstractFooMethod(): string {
                return 'abstractFooMethod';
            }
        }

        const fooCtor = ctor.newAbstract<typeof Foo, FooParams>(Foo, {
            foo: 'foo',
        });
        const bar = from(fooCtor).new(Bar, { bar: 'bar' }).construct();

        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);

        expect(bar.foo).toBe('foo');
        expect(bar.fooMethod()).toBe('fooMethod');
        expect(bar.bar).toBe('bar');
        expect(bar.abstractFooMethod()).toBe('abstractFooMethod');
    });

    it('allows static factories of the same name across inherited classes', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public static from(foo: string): ctor<Foo> {
                return ctor.new(Foo, { foo });
            }
        }

        class Bar extends Implementation<Foo>() {
            public readonly bar: string;

            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            // Same name as `Foo.from()`, but should not conflict.
            public static from(foo: string, bar: string): Bar {
                return from(Foo.from(foo)).new(Bar, { bar }).construct();
            }
        }

        const bar = Bar.from('foo', 'bar');
        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);
        expect(bar.foo).toBe('foo');
        expect(bar.bar).toBe('bar');
    });

    it('`instanceof` works as expected', () => {
        class Foo { }
        class Bar extends Foo { }
        class Baz extends Bar { }
        class Unrelated { }

        const foo = ctor.new(Foo).construct();
        expect(foo).toBeInstanceOf(Foo);

        const bar = from(ctor.new(Bar)).new(Foo).construct();
        expect(bar).toBeInstanceOf(Bar);
        expect(bar).toBeInstanceOf(Foo);

        const baz = from(from(ctor.new(Bar)).new(Foo)).new(Baz).construct();
        expect(baz).toBeInstanceOf(Baz);
        expect(baz).toBeInstanceOf(Bar);
        expect(baz).toBeInstanceOf(Foo);

        expect(baz).not.toBeInstanceOf(Unrelated);
    });

    it('extends Object', () => {
        class Foo { }
        class Bar extends Implementation<Foo>() { }

        const foo = ctor.new(Foo).construct();
        expect(foo).toBeInstanceOf(Object);

        const bar = from(ctor.new(Foo)).new(Bar).construct();
        expect(bar).toBeInstanceOf(Object);
    });

    it('chooses its superclass implementation at construction time', () => {
        interface Parent {
            parent: string;
            parentMethod(): string;
        }

        class ParentA implements Parent {
            public readonly parent: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ parent }: { parent: string }) {
                this.parent = parent;
            }

            public parentMethod(): string {
                return 'parentMethodA';
            }

            public static from(parent: string): ctor<ParentA> {
                return ctor.new(ParentA, { parent: `${parent}A` });
            }
        }

        class ParentB implements Parent {
            public readonly parent: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ parent }: { parent: string }) {
                this.parent = parent;
            }

            public parentMethod(): string {
                return 'parentMethodB';
            }

            public static from(parent: string): ctor<ParentB> {
                return ctor.new(ParentB, { parent: `${parent}B` });
            }
        }

        class Child extends Implementation<Parent>() {
            public readonly child: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ child }: { child: string }) {
                super();
                this.child = child;
            }

            public childMethod(): string {
                return 'childMethod';
            }

            public static from(
                    parent: string, child: string, useParentA: boolean): Child {
                // Dynamically choose which superclass to inherit from at
                // construction time.
                const parentCtor = useParentA
                        ? ParentA.from(parent) : ParentB.from(parent);
                return from(parentCtor).new(Child, { child }).construct();
            }

            // Allow user of Child to choose which Parent implementation to use.
            public static fromParent(
                    parentCtor: ctor<Parent>, child: string): Child {
                return from(parentCtor).new(Child, { child }).construct();
            }
        }

        const childA1 = Child.from('parent', 'child', true /* useParentA */);
        expect(childA1).toBeInstanceOf(Child);
        expect(childA1).toBeInstanceOf(ParentA);
        expect(childA1.child).toBe('child');
        expect(childA1.childMethod()).toBe('childMethod');
        expect(childA1.parent).toBe('parentA');
        expect(childA1.parentMethod()).toBe('parentMethodA');
        // @ts-expect-error Should not have `any` index type.
        (() => childA1.doesNotExist);

        const childB1 = Child.from('parent', 'child', false /* useParentA */);
        expect(childB1).toBeInstanceOf(Child);
        expect(childB1).toBeInstanceOf(ParentB);
        expect(childB1.child).toBe('child');
        expect(childB1.childMethod()).toBe('childMethod');
        expect(childB1.parent).toBe('parentB');
        expect(childB1.parentMethod()).toBe('parentMethodB');
        // @ts-expect-error Should not have `any` index type.
        (() => childB1.doesNotExist);

        const childA2 = Child.fromParent(ParentA.from('parent'), 'child');
        expect(childA2).toBeInstanceOf(Child);
        expect(childA2).toBeInstanceOf(ParentA);
        expect(childA2.child).toBe('child');
        expect(childA2.childMethod()).toBe('childMethod');
        expect(childA2.parent).toBe('parentA');
        expect(childA2.parentMethod()).toBe('parentMethodA');
        // @ts-expect-error Should not have `any` index type.
        (() => childA2.doesNotExist);

        const childB2 = Child.fromParent(ParentB.from('parent'), 'child');
        expect(childB2).toBeInstanceOf(Child);
        expect(childB2).toBeInstanceOf(ParentB);
        expect(childB2.child).toBe('child');
        expect(childB2.childMethod()).toBe('childMethod');
        expect(childB2.parent).toBe('parentB');
        expect(childB2.parentMethod()).toBe('parentMethodB');
        // @ts-expect-error Should not have `any` index type.
        (() => childB2.doesNotExist);
    });
});
