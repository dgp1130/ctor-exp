/** @fileoverview Examples of mixin usage. */

import { Implementation, ctor, from } from './ctor';

describe('mixin', () => {
    it('mixes in a unconstrained mixin', () => {
        class Parent {
            public readonly parent: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ parent }: { parent: string }) {
                this.parent = parent;
            }

            public static from(parent: string): ctor<Parent> {
                return ctor.new(Parent, { parent });
            }
        }

        class Mixin extends Implementation() {
            public readonly mixin: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ mixin }: { mixin: string }) {
                super();
                this.mixin = mixin;
            }

            public static from<Parent>(
                    parent: ctor<Parent>, mixin: string): ctor<Mixin & Parent> {
                return from(parent).mixin(Mixin, { mixin });
            }
        }

        class Child extends Implementation<Mixin & Parent>() {
            public readonly child: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ child }: { child: string }) {
                super();
                this.child = child;
            }

            public static from(
                    parent: string, mixin: string, child: string): Child {
                const parentCtor = Parent.from(parent);
                const mixinCtor = Mixin.from(parentCtor, mixin);
                return from(mixinCtor).new(Child, { child }).construct();
            }
        }

        const child = Child.from('parent', 'mixin', 'child');
        expect(child).toBeInstanceOf(Child);
        expect(child).toBeInstanceOf(Mixin);
        expect(child).toBeInstanceOf(Parent);
        expect(child.child).toBe('child');
        expect(child.mixin).toBe('mixin');
        expect(child.parent).toBe('parent');
        // @ts-expect-error Should not have `any` index type.
        (() => child.doesNotExist);
    });

    it('mixes in a constrained mixin', () => {
        interface Base {
            baseMethod(): string;
        }

        class BaseParent implements Base {
            public readonly parent: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ parent }: { parent: string }) {
                this.parent = parent;
            }

            public baseMethod(): string {
                return `${this.parent}Method`;
            }

            public static from(parent: string): ctor<BaseParent> {
                return ctor.new(BaseParent, { parent });
            }
        }

        // This Mixin has no knowledge of `Parent`, it extends "some
        // implementation of the Base interface".
        class Mixin extends Implementation<Base>() {
            public readonly mixin: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ mixin }: { mixin: string }) {
                super();
                this.mixin = mixin;
            }

            public mixinMethod(): string {
                return `${this.baseMethod()} + ${this.mixin}Method`;
            }

            public static from<Parent extends Base>(
                    parent: ctor<Parent>, mixin: string): ctor<Mixin & Parent> {
                return from(parent).mixin(Mixin, { mixin });
            }
        }

        class Child extends Implementation<Mixin & BaseParent>() {
            public readonly child: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ child }: { child: string }) {
                super();
                this.child = child;
            }

            public childMethod(): string {
                return `${this.child}Method`;
            }

            public static from(
                    parent: string, mixin: string, child: string): Child {
                const parentCtor = BaseParent.from(parent);
                const mixinCtor = Mixin.from(parentCtor, mixin);
                return from(mixinCtor).new(Child, { child }).construct();
            }
        }

        const child = Child.from('parent', 'mixin', 'child');
        expect(child).toBeInstanceOf(Child);
        expect(child).toBeInstanceOf(Mixin);
        expect(child).toBeInstanceOf(Child);
        expect(child.child).toBe('child');
        expect(child.mixin).toBe('mixin');
        expect(child.parent).toBe('parent');
        
        expect(child.baseMethod()).toBe('parentMethod');
        expect(child.mixinMethod()).toBe('parentMethod + mixinMethod');
        expect(child.childMethod()).toBe('childMethod');
        // @ts-expect-error Should not have `any` index type.
        (() => child.doesNotExist);
    });
    
    it('prevents mixing in to a parent class which does not match mixin constraints', () => {
        interface Base {
            bases(): string;
        }

        class UnrelatedParent {
            public readonly parent: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ parent }: { parent: string }) {
                this.parent = parent;
            }

            public static from(parent: string): ctor<UnrelatedParent> {
                return ctor.new(UnrelatedParent, { parent });
            }
        }

        class Mixin extends Implementation<Base>() {
            public readonly mixin: string;
            public readonly base: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ mixin }: { mixin: string }) {
                super();
                this.mixin = mixin;
                this.base = this.bases();
            }

            public static from<Parent extends Base>(
                    parent: ctor<Parent>, mixin: string): ctor<Mixin & Parent> {
                return from(parent).mixin(Mixin, { mixin });
            }
        }

        class Child extends Implementation<Mixin & UnrelatedParent>() {
            public readonly child: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ child }: { child: string }) {
                super();
                this.child = child;
            }

            public static from(
                    parent: string, mixin: string, child: string): Child {
                const parentCtor = UnrelatedParent.from(parent);
                // @ts-expect-error Cannot extend a parent which does not
                // implement Base.
                const mixinCtor = Mixin.from(parentCtor, mixin);
                return from(mixinCtor).new(Child, { child }).construct();
            }
        }

        expect().nothing();
    });
});
