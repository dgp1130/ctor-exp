/**
 * @fileoverview Tests that the system type checks as expected. Most of these
 * tests don't actually test anything at runtime, and instead use
 * @ts-expect-error to make the compiler fail a build if an error is not thown
 * where it is expected.
 */

import { ctor, from } from './ctor';

describe('typing', () => {
    it('verifies constructor parameters', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }
        }

        // @ts-expect-error Foo expects a string, not a number.
        (() => ctor.new(Foo, 0));
        expect().nothing();
    });

    it('verifies child class constructor parameters', () => {
        class Foo {
            public readonly foo: string;
            
            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }
        }

        class Bar extends Foo {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor(
                superParams: ConstructorParameters<typeof Foo>,
                { bar }: { bar: string }
            ) {
                super(...superParams);
                this.bar = bar;
            }
        }

        const fooCtor = ctor.new(Foo, { foo: 'foo' });
        // @ts-expect-error Bar expects a string, not a number.
        (() => from(fooCtor).new(Bar, 0));
        expect().nothing();
    });

    it('prevents extending unrelated classes', () => {
        class Foo {
            public readonly foo: string;
            
            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }
        }
        class Bar {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ bar }: { bar: string }) {
                this.bar = bar;
            }
        }

        // Unfortunately, this is only a best-effort. If Foo and Bar happen to
        // be structurally compatible, this check may incorrectly pass.
        // @ts-expect-error Bar does not extend Foo.
        (() => from(ctor.new(Foo, 'foo')).new(Bar, 'bar'));
        expect().nothing();
    });
});

describe('typing does **not** but definitely should', () => {
    it('limit ctor.new() usage to be private to the constructed class', () => {
        class Foo {
            public readonly foo: string;
            
            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }
        }

        // Users should be required to go through a public factory exposed by
        // the `Foo` class.
        (() => ctor.new(Foo, { foo: 'foo' }).construct());
        expect().nothing();
    });

    it('require `from()` to extend a class', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }
        }

        class Bar extends Foo {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor(
                superParams: ConstructorParameters<typeof Foo>,
                { bar }: { bar: string },
            ) {
                super(...superParams);
                this.bar = bar;
            }
        }

        // Users should be required to use `from()` to extend `Foo`, rather than
        // directly passing in its parameters to `ctor.new()`.
        (() => ctor.new(Bar, [ { foo: 'foo' } ], { bar: 'bar' }).construct());
        expect().nothing();
    });

    it('infer types of constructor parameters for abstract classes', () => {
        abstract class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }
        }

        class Bar extends Foo {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor(
                // @ts-expect-error Cannot retrieve constructor of abstract Foo.
                superParams: ConstructorParameters<typeof Foo>,
                { bar }: { bar: string },
            ) {
                // @ts-expect-error Cannot validate `super()` call.
                super(...superParams);
                this.bar = bar;
            }
        }

        expect().nothing();
    });

    it('shadow superclass factories', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public static create(foo: string): ctor<Foo> {
                return ctor.new(Foo, { foo });
            }
        }

        // @ts-expect-error Cannot reuse the name `create()` because the types
        // aren't compatible. These should be treated as independent functions
        // with no type relation to each other.
        class Bar extends Foo {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor(
                superParams: ConstructorParameters<typeof Foo>,
                { bar }: { bar: string },
            ) {
                super(...superParams);
                this.bar = bar;
            }

            public static create(foo: string, bar: string): ctor<Bar> {
                return from(Foo.create(foo)).new(Bar, { bar });
            }
        }

        expect().nothing();
    });
});
