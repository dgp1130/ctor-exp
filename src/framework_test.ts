/** @fileoverview Example of a framework that constructs user-owned classes. */

import { ctor, from, Implementation } from './ctor';

describe('frameworks', () => {
    it('cannot easily create user objects', () => {
        // Some superclass owned by the framework. All components have a tagName
        // which should be provided by the framework automatically.
        abstract class Component {
            protected constructor(protected readonly tagName: string) { }
            public abstract render(): string;
        }

        // A registry of objects for the framework to create. Note that we
        // cannot use a constructor type, because we do not know what
        // constructor parameters are used by `Component` subclass.
        const registry = new Map<string, (tagName: string) => Component>();
        function registerComponent(
            tagName: string,
            createComponent: (tagName: string) => Component,
        ): void {
            registry.set(tagName, createComponent);
        }

        // Framework automatically creates `Component` objects when it finds the
        // corresponding tag name.
        function createComponent(tagName: string): Component {
            const createComponent = registry.get(tagName);
            if (!createComponent) {
                throw new Error(`No component for ${tagName}`);
            }

            return createComponent(tagName);
        }

        // Define a user-level subclass using the framework provided superclass.
        class HelloWorldComponent extends Component {
            public constructor(tagName: string, private readonly name: string) {
                // Must awkwardly accept and propagate framework-owned data.
                // In this example, if the framework ever wanted to pass
                // additional data, it would be a breaking change for all user
                // classes. It is possible to work around this via a black-boxed
                // type or a dependent type, however not all languages provide
                // great utilities to hide the implementation details of this
                // framework-specific data object.
                super(tagName);
            }

            public render(): string {
                return `Hello, ${this.name}. I am ${this.tagName}.`;
            }
        }

        // Can't register just `HelloWorldComponent` because the framework does
        // not know how to construct it. Instead, we must use a lambda so we can
        // provide extra component-specific data and pass through the framework
        // data that we don't care about and could screw up.
        registerComponent('hello-world', (tagName: string) => {
            return new HelloWorldComponent(tagName, 'World');
        });

        // Simulate the framework creating the component based on its tag name.
        const helloWorldComponent = createComponent('hello-world');
        expect(helloWorldComponent.render())
                .toBe('Hello, World. I am hello-world.');
    });

    it('can easily create user objects with ctor<T>', () => {
        // Must explicitly define an interface for abstract classes because of
        // TypeScript weirdness. This shouldn't be necessary in a real
        // implementation.
        interface ComponentParams {
            tagName: string;
        }

        // Some superclass owned by the framework. All components have a tagName
        // which should be provided by the framework automatically.
        abstract class Component {
            protected readonly tagName: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ tagName }: ComponentParams) {
                this.tagName = tagName;
            }

            public abstract render(): string;

            public static fromTagName(tagName: string): ctor<Component> {
                return ctor.newAbstract<typeof Component, [ ComponentParams ]>(
                        Component, { tagName });
            }
        }

        // A registry of objects for the framework to create. Note that we
        // cannot use a constructor type, because we do not know what
        // constructor parameters are used by `Component` subclass.
        const registry = new Map<
            string,
            (parent: ctor<Component>) => Component
        >();
        function registerComponent(
            tagName: string,
            createComponent: (parentCtor: ctor<Component>) => Component,
        ): void {
            registry.set(tagName, createComponent);
        }

        // Framework automatically creates `Component` objects when it finds the
        // corresponding tag name.
        function createComponent(tagName: string): Component {
            const createComponent = registry.get(tagName);
            if (!createComponent) {
                throw new Error(`No component for ${tagName}`);
            }

            return createComponent(Component.fromTagName(tagName));
        }

        // Define a user-level subclass using the framework provided superclass.
        class HelloWorldComponent extends Implementation<Component>() {
            private readonly name: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ name }: { name: string }) {
                super();
                this.name = name;
            }

            public render(): string {
                return `Hello, ${this.name}. I am ${this.tagName}.`;
            }

            public static fromParent(parentCtor: ctor<Component>, name: string):
                    HelloWorldComponent {
                return from(parentCtor)
                        .new(HelloWorldComponent, { name })
                        .construct();
            }
        }

        // Register the user-level component by simply extending the framework
        // provided `ctor<T>` object. While this isn't that different from the
        // non-`ctor<T>` example, it does use the existing mechanics and
        // conventions of construction to achieve its goals, rather than
        // requiring users to understand and pass through an extra parameter.
        registerComponent('hello-world', (parentCtor: ctor<Component>) => {
            return HelloWorldComponent.fromParent(parentCtor, 'World');
        });

        // Simulate the framework creating the component based on its tag name.
        const helloWorldComponent = createComponent('hello-world');
        expect(helloWorldComponent.render())
                .toBe('Hello, World. I am hello-world.');
    });
});
