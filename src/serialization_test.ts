/** @fileoverview Examples of serializing/deserializing object heirarchies. */

import { ctor, from, Implementation } from './ctor';

describe('serialization', () => {
    it('is normally not composable', () => {
        interface SerializedFoo {
            serialFoo: string;
        }
        class Foo {
            private readonly foo: string;

            // We want to just construct off a single string, but we're forced
            // into supporting `SerializedFoo` in this constructor.
            public constructor(param: string | SerializedFoo) {
                if (typeof param === 'string') {
                    this.foo = param;
                } else {
                    this.foo = param.serialFoo;
                }
            }

            public serialize(): SerializedFoo {
                return { serialFoo: this.foo };
            }

            public static deserialize(serial: SerializedFoo): Foo {
                // **Must** use an akward copy-constructor like trick in order
                // to make this composable with subclass `deserialize()`
                // functions.
                return new Foo(serial);
            }
        }

        interface SerializedBar extends SerializedFoo {
            serialBar: string;
        }
        class Bar extends Foo {
            public readonly bar: string;

            // This gets even more awkward as the cosntructor gets more
            // complicated. We need to support either deserializing from a
            // `SerializedBar`, or constructing from two strings.
            public constructor(params: SerializedBar | [
                foo: string,
                bar: string,
            ]) {
                if (Array.isArray(params)) {
                    const [ foo, bar ] = params;
                    super(foo);
                    this.bar = bar;
                } else {
                    super(params);
                    this.bar = params.serialBar;
                }
            }

            public serialize(): SerializedBar {
                return {
                    ...super.serialize(),
                    serialBar: this.bar,
                };
            }

            public static deserialize(serial: SerializedBar): Bar {
                return new Bar(serial);
            }
        }

        // Using `Bar` is now more awkward, using an array shouldn't be needed!
        const bar = new Bar([ 'foo', 'bar' ]);
        const serializedBar = bar.serialize();
        expect(serializedBar).toEqual({
            serialFoo: 'foo',
            serialBar: 'bar',
        });

        const deserializedBar = Bar.deserialize(serializedBar);
        expect(deserializedBar).toEqual(bar);
        expect(deserializedBar).not.toBe(bar);
    });

    it('supports serialization', () => {
        interface SerializedFoo {
            serialFoo: string;
        }
        class Foo {
            private readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            public serialize(): SerializedFoo {
                return { serialFoo: this.foo };
            }

            // Deserialization is just a factory, easily composeable! No need
            // for a copy constructor!
            public static deserialize(serial: SerializedFoo): ctor<Foo> {
                return ctor.new(Foo, { foo: serial.serialFoo });
            }
        }

        interface SerializedBar extends SerializedFoo {
            serialBar: string;
        }
        class Bar extends Implementation<Foo>() {
            private readonly bar: string;
            
            /** Boilerplate, should be generated by compiler. */
            public constructor({ bar }: { bar: string }) {
                super();
                this.bar = bar;
            }

            public serialize(): SerializedBar {
                return {
                    ...this._super.serialize(),
                    serialBar: this.bar,
                };
            }

            // `Bar` simply composes `Foo.prototype.deserialize()` intuitively.
            // No awkward copy constructors.
            public static deserialize(serial: SerializedBar): ctor<Bar> {
                return from(Foo.deserialize(serial)).new(Bar, {
                    bar: serial.serialBar,
                });
            }
        }

        // Construction API is unaffected, no awkward array literal here!
        const fooCtor = ctor.new(Foo, { foo: 'foo' });
        const bar = from(fooCtor).new(Bar, { bar: 'bar' }).construct();
        const serializedBar = bar.serialize();
        expect(serializedBar).toEqual({
            serialFoo: 'foo',
            serialBar: 'bar',
        });

        const deserializedBar = Bar.deserialize(serializedBar).construct();
        expect(deserializedBar).toEqual(bar);
        expect(deserializedBar).not.toBe(bar);
    });
});
