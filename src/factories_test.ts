/** @fileoverview Examples of common factory usage. */

import { ctor, from } from './ctor';

describe('factories', () => {
    it('normally cannot be composed with each other', () => {
        class Foo {
            public readonly foo: string;
            protected constructor(foo: string) {
                this.foo = foo;
            }

            // Can't instantiate `Foo`, because the user may want a subclass.
            // Instead we have to awkwardly return `Foo`'s constructor
            // parameters and trust that the subclass does the right thing.
            public static createFooParams(foo: string): string {
                return Array.from(foo).reverse().join('');
            }
        }

        class Bar extends Foo {
            public readonly bar: string;
            private constructor(foo: string, bar: string) {
                super(foo);
                this.bar = bar;
            }

            public static createBar(foo: string, bar: string) {
                const fooData = Foo.createFooParams(foo);

                // Need to pass Foo factory data back into its own constructor.
                return new Bar(fooData, bar);
            }
        }

        const bar = Bar.createBar('foo', 'bar');
        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);
        expect(bar.foo).toBe('oof');
        expect(bar.bar).toBe('bar');
    });

    it('with ctor<T>, factories are easily composed', () => {
        class Foo {
            public readonly foo: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor({ foo }: { foo: string }) {
                this.foo = foo;
            }

            // Don't need to awkwardly pass around `Foo`'s constructor
            // parameters. Just return a `ctor<Foo>`!
            public static createFoo(foo: string): ctor<Foo> {
                return ctor.new(Foo, { foo });
            }
        }

        class Bar extends Foo {
            public readonly bar: string;

            /** Boilerplate, should be generated by compiler. */
            public constructor(
                superParams: ConstructorParameters<typeof Foo>,
                { bar }: { bar: string },
            ) {
                super(...superParams);
                this.bar = bar;
            }

            // `Bar`'s factory can easily reuse `Foo`'s factory, thanks to
            // `ctor<T>`!
            public static createBar(foo: string, bar: string): Bar {
                return from(Foo.createFoo(foo)).new(Bar, { bar }).construct();
            }
        }

        const bar = Bar.createBar('foo', 'bar');

        expect(bar).toBeInstanceOf(Foo);
        expect(bar).toBeInstanceOf(Bar);
        expect(bar.foo).toBe('foo');
        expect(bar.bar).toBe('bar');
    });
});
